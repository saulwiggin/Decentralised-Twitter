{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.storeAsStream = void 0;\n\nconst stream_1 = require(\"stream\");\n\nclass ObservableStoreStream extends stream_1.Duplex {\n  constructor(obsStore) {\n    super({\n      // pass values, not serializations\n      objectMode: true\n    }); // dont buffer outgoing updates\n\n    this.resume(); // save handler so we can unsubscribe later\n\n    this.handler = state => this.push(state); // subscribe to obsStore changes\n\n\n    this.obsStore = obsStore;\n    this.obsStore.subscribe(this.handler);\n  } // emit current state on new destination\n\n\n  pipe(dest, options) {\n    const result = super.pipe(dest, options);\n    dest.write(this.obsStore.getState());\n    return result;\n  } // write from incoming stream to state\n\n\n  _write(chunk, _encoding, callback) {\n    this.obsStore.putState(chunk);\n    callback();\n  } // noop - outgoing stream is asking us if we have data we arent giving it\n\n\n  _read(_size) {\n    return undefined;\n  } // unsubscribe from event emitter\n\n\n  _destroy(err, callback) {\n    this.obsStore.unsubscribe(this.handler);\n\n    super._destroy(err, callback);\n  }\n\n}\n\nfunction storeAsStream(obsStore) {\n  return new ObservableStoreStream(obsStore);\n}\n\nexports.storeAsStream = storeAsStream;","map":{"version":3,"mappings":";;;;;;;AAAA;;AAIA,MAAMA,qBAAN,SAAuCC,eAAvC,CAAmD;EAKjDC,YAAYC,QAAZ,EAAwC;IACtC,MAAM;MACJ;MACAC,UAAU,EAAE;IAFR,CAAN,EADsC,CAKtC;;IACA,KAAKC,MAAL,GANsC,CAOtC;;IACA,KAAKC,OAAL,GAAgBC,KAAD,IAAc,KAAKC,IAAL,CAAUD,KAAV,CAA7B,CARsC,CAStC;;;IACA,KAAKJ,QAAL,GAAgBA,QAAhB;IACA,KAAKA,QAAL,CAAcM,SAAd,CAAwB,KAAKH,OAA7B;EACD,CAjBgD,CAmBjD;;;EACAI,IAAI,CACFC,IADE,EAEFC,OAFE,EAEyB;IAE3B,MAAMC,MAAM,GAAG,MAAMH,IAAN,CAAWC,IAAX,EAAiBC,OAAjB,CAAf;IACAD,IAAI,CAACG,KAAL,CAAW,KAAKX,QAAL,CAAcY,QAAd,EAAX;IACA,OAAOF,MAAP;EACD,CA3BgD,CA6BjD;;;EACAG,MAAM,CACJC,KADI,EAEJC,SAFI,EAGJC,QAHI,EAGoC;IAExC,KAAKhB,QAAL,CAAciB,QAAd,CAAuBH,KAAvB;IACAE,QAAQ;EACT,CArCgD,CAuCjD;;;EACAE,KAAK,CAACC,KAAD,EAAc;IACjB,OAAOC,SAAP;EACD,CA1CgD,CA4CjD;;;EACAC,QAAQ,CAACC,GAAD,EAAoBN,QAApB,EAA2D;IACjE,KAAKhB,QAAL,CAAcuB,WAAd,CAA0B,KAAKpB,OAA/B;;IACA,MAAMkB,QAAN,CAAeC,GAAf,EAAoBN,QAApB;EACD;;AAhDgD;;AAmDnD,SAAgBQ,aAAhB,CACExB,QADF,EAC8B;EAE5B,OAAO,IAAIH,qBAAJ,CAA0BG,QAA1B,CAAP;AACD;;AAJDyB","names":["ObservableStoreStream","stream_1","constructor","obsStore","objectMode","resume","handler","state","push","subscribe","pipe","dest","options","result","write","getState","_write","chunk","_encoding","callback","putState","_read","_size","undefined","_destroy","err","unsubscribe","storeAsStream","exports"],"sourceRoot":"","sources":["../src/asStream.ts"],"sourcesContent":["import { Duplex as DuplexStream } from 'stream';\n\nimport { ObservableStore } from './ObservableStore';\n\nclass ObservableStoreStream<T> extends DuplexStream {\n  handler: (state: T) => void;\n\n  obsStore: ObservableStore<T>;\n\n  constructor(obsStore: ObservableStore<T>) {\n    super({\n      // pass values, not serializations\n      objectMode: true,\n    });\n    // dont buffer outgoing updates\n    this.resume();\n    // save handler so we can unsubscribe later\n    this.handler = (state: T) => this.push(state);\n    // subscribe to obsStore changes\n    this.obsStore = obsStore;\n    this.obsStore.subscribe(this.handler);\n  }\n\n  // emit current state on new destination\n  pipe<U extends NodeJS.WritableStream>(\n    dest: U,\n    options?: { end?: boolean },\n  ): U {\n    const result = super.pipe(dest, options);\n    dest.write(this.obsStore.getState() as any);\n    return result;\n  }\n\n  // write from incoming stream to state\n  _write(\n    chunk: any,\n    _encoding: string,\n    callback: (error?: Error | null) => void,\n  ): void {\n    this.obsStore.putState(chunk);\n    callback();\n  }\n\n  // noop - outgoing stream is asking us if we have data we arent giving it\n  _read(_size: number): void {\n    return undefined;\n  }\n\n  // unsubscribe from event emitter\n  _destroy(err: Error | null, callback: (error: Error | null) => void): void {\n    this.obsStore.unsubscribe(this.handler);\n    super._destroy(err, callback);\n  }\n}\n\nexport function storeAsStream<T>(\n  obsStore: ObservableStore<T>,\n): ObservableStoreStream<T> {\n  return new ObservableStoreStream(obsStore);\n}\n"]},"metadata":{},"sourceType":"script"}